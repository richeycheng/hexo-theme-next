<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,Shell,">










<meta name="description" content="一. Linux shell 脚本攻略1. 命令行的起始标志username@hostname $root@hostname #$表示普通用户，#表示管理员用户root。   2. shebang文本行#!/bin/bash   #!位于解释器路径之前，/bin/bash是Bash的解释器命令路径。运行脚本的方式有两种：(1) 将脚本作为命令行参数，例如：$ sh script.sh，此时不需要s">
<meta name="keywords" content="Linux,Shell">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux shell脚本攻略">
<meta property="og:url" content="http://yoursite.com/2020/05/16/Linux shell脚本攻略/index.html">
<meta property="og:site_name" content="Richey&#39;s Notes">
<meta property="og:description" content="一. Linux shell 脚本攻略1. 命令行的起始标志username@hostname $root@hostname #$表示普通用户，#表示管理员用户root。   2. shebang文本行#!/bin/bash   #!位于解释器路径之前，/bin/bash是Bash的解释器命令路径。运行脚本的方式有两种：(1) 将脚本作为命令行参数，例如：$ sh script.sh，此时不需要s">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-16T04:33:57.038Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux shell脚本攻略">
<meta name="twitter:description" content="一. Linux shell 脚本攻略1. 命令行的起始标志username@hostname $root@hostname #$表示普通用户，#表示管理员用户root。   2. shebang文本行#!/bin/bash   #!位于解释器路径之前，/bin/bash是Bash的解释器命令路径。运行脚本的方式有两种：(1) 将脚本作为命令行参数，例如：$ sh script.sh，此时不需要s">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/16/Linux shell脚本攻略/">





  <title>Linux shell脚本攻略 | Richey's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Richey's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">温故知新</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/Linux shell脚本攻略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RicheyCheng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://ww3.sinaimg.cn/mw690/eab689f0jw8f12gq1h4q0j20ig0igjsh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richey's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux shell脚本攻略</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-16T11:16:06+08:00">
                2020-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一-Linux-shell-脚本攻略"><a href="#一-Linux-shell-脚本攻略" class="headerlink" title="一. Linux shell 脚本攻略"></a>一. Linux shell 脚本攻略</h3><h4 id="1-命令行的起始标志"><a href="#1-命令行的起始标志" class="headerlink" title="1. 命令行的起始标志"></a>1. 命令行的起始标志</h4><p>username@hostname $<br>root@hostname #<br>$表示普通用户，#表示管理员用户root。  </p>
<h4 id="2-shebang文本行"><a href="#2-shebang文本行" class="headerlink" title="2. shebang文本行"></a>2. shebang文本行</h4><p>#!/bin/bash  </p>
<p>#!位于解释器路径之前，/bin/bash是Bash的解释器命令路径。<br>运行脚本的方式有两种：<br>(1) 将脚本作为命令行参数，例如：$ sh script.sh，此时不需要shebang。<br>(2) 授予脚本执行权限，将其变为可执行脚本，内核会根据shebang识别执行方式，例如：$ ./script.sh。  </p>
<h4 id="3-Bash分隔符"><a href="#3-Bash分隔符" class="headerlink" title="3. Bash分隔符"></a>3. Bash分隔符</h4><p>在Bash中，每个命令或命令序列是通过使用分号或换行符来分隔的。</p>
<h4 id="4-终端打印命令—echo"><a href="#4-终端打印命令—echo" class="headerlink" title="4. 终端打印命令—echo"></a>4. 终端打印命令—echo</h4><p>(1) 不带引号：无法显示分号(;)，因为分号在Bash shell被当作命令定界符。<br>(2) 带单引号：单引号中，变量不会被扩展，将依照原样显示。<br>(3) 带双引号：变量会被扩展。<br>(4) 默认情况下，echo会将一个换行符追加到输出文本的尾部，可以使用选项-n来忽略结尾的换行符。<br>(5) 如果需要使用转义序列，则采用选项-e。  </p>
<h4 id="5-终端打印命令—printf"><a href="#5-终端打印命令—printf" class="headerlink" title="5. 终端打印命令—printf"></a>5. 终端打印命令—printf</h4><p>默认情况下，printf并不会像echo命令一样会自动添加换行符。<br>%s: 字符串<br>%c: 字符<br>%d: 整型数<br>%f: 浮点数<br>.2: 保留2个小数位<br>-5: -表示左对齐(默认右对齐)，5表示宽度为5<br>例如：printf “%-5s %-10s %-4.2f\n” 1 James 90.9989  </p>
<h4 id="6-赋值与相等"><a href="#6-赋值与相等" class="headerlink" title="6. 赋值与相等"></a>6. 赋值与相等</h4><p>(1) 在Bash中，每一个变量的值都是字符串。无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。<br>(2) 赋值：var=value。如果value不包含任何空白字符（例如空格），那么就不需要使用引号进行引用，否则必须使用单引号或双引号。<br>(3) 相等：var = value。</p>
<h4 id="7-export命令"><a href="#7-export命令" class="headerlink" title="7. export命令"></a>7. export命令</h4><p>export命令用来设置环境变量。<br>(1) export PATH=”$PATH:/home/user/bin”<br>或者<br>(2) PATH=”$PATH:/home/user/bin”<br>   export PATH</p>
<h4 id="8-检查用户是否为root"><a href="#8-检查用户是否为root" class="headerlink" title="8. 检查用户是否为root"></a>8. 检查用户是否为root</h4><p>环境变量UID可以用于检查当前脚本是以超级用户root还是以普通用户的身份运行。例如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $UID -eq 0 ]; then</span><br><span class="line">    echo &quot;Root User&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="9-反引用与子shell"><a href="#9-反引用与子shell" class="headerlink" title="9. 反引用与子shell"></a>9. 反引用与子shell</h4><p>反引用：`command`<br>子shell：$(command)。  </p>
<p>子shelll本身是独立的进程，可以使用()操作符来定义一个子shell，例如下面的脚本，两次pwd命令的结果是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br><span class="line">(cd /bin; ls)</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>假设使用子shell或反引用将命令的输出读入一个变量中，可以将它放入双引号中，以保留空格和换行符(\n)。</p>
<h4 id="10-数学运算"><a href="#10-数学运算" class="headerlink" title="10. 数学运算"></a>10. 数学运算</h4><p>(1) 在Bash shell环境中，可以利用let、(())和[]执行基本的算术操作。而在进行高级操作时，expr和bc这两个工具也会非常有用。<br>(2) let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result=num1+num2  </span><br><span class="line">let num1++</span><br><span class="line">let num1--</span><br><span class="line">let num2+=10</span><br></pre></td></tr></table></figure>

<p>(3) [ .. ] 和 (( .. ))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=$[ num1 + num2 ]</span><br><span class="line">result=$(( num1 + num2 ))</span><br></pre></td></tr></table></figure>

<p>(4) expr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=`expr 3 + 4`</span><br><span class="line">result=$(expr $num1 + 10)</span><br></pre></td></tr></table></figure>

<h4 id="11-bc"><a href="#11-bc" class="headerlink" title="11. bc"></a>11. bc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 + 2&quot; | bc</span><br><span class="line">echo &quot;4 * 0.56&quot; | bc</span><br><span class="line">result=`echo &quot;$num * 1.5&quot; | bc`</span><br></pre></td></tr></table></figure>

<p>(1) 设定小数精度<br>参数scale=2将小数位个数设置为2。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;scale=2;10/3&quot; | bc  </span><br><span class="line">3.33</span><br></pre></td></tr></table></figure>

<p>(2) 进制转换<br>ibase表示输入（默认十进制），obase表示输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num=100</span><br><span class="line">echo &quot;obase=2;$num&quot; | bc</span><br><span class="line">1100100</span><br><span class="line"></span><br><span class="line">num=1100100</span><br><span class="line">echo &quot;obase=10;ibase=2;$num&quot; | bc</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>(3) 平方与平方根  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sqrt(100)&quot; | bc</span><br><span class="line">echo &quot;10^2&quot; | bc</span><br></pre></td></tr></table></figure>

<h4 id="12-数组与关联数组"><a href="#12-数组与关联数组" class="headerlink" title="12. 数组与关联数组"></a>12. 数组与关联数组</h4><p>(1) 数组的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array_var=(1 2 3 4 5)</span><br><span class="line">或</span><br><span class="line">array_var[0]=&quot;val1&quot;</span><br><span class="line">array_var[1]=&quot;val2&quot;</span><br></pre></td></tr></table></figure>

<p>(2) 在关联数组中，可以用任意的文本作为数组索引。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare -A ass_array</span><br><span class="line">ass_array=([index1]=val1 [index2]=val2)</span><br><span class="line">或</span><br><span class="line">ass_array[index1]=val1</span><br><span class="line">ass_array[index2]=val2</span><br></pre></td></tr></table></figure>

<p>(3) 获取数组相关的值（注意：花括号{}不能省略！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">获取数组值列表：  </span><br><span class="line">echo $&#123;array_var[*]&#125; 或 echo $&#123;array_var[@]&#125;  </span><br><span class="line"></span><br><span class="line">获取索引列表：  </span><br><span class="line">echo $&#123;!array_var[*]&#125; 或 echo $&#123;!array_var[@]&#125;  </span><br><span class="line"></span><br><span class="line">获取数组长度：  </span><br><span class="line">echo $&#123;#array_var[*]&#125; 或 echo $&#123;#array_var[@]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-别名"><a href="#13-别名" class="headerlink" title="13. 别名"></a>13. 别名</h4><p>(1) 定义别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias new_command=&apos;command sequence&apos;</span><br><span class="line">例如：</span><br><span class="line">alias install=&apos;sudo apt-get install&apos;</span><br></pre></td></tr></table></figure>

<p>为了使别名设置一直保持作用，可以将它放入<code>~/.bashrc</code>文件中。因为每当一个新的shell进程生成时，都会执行<code>~/.bashrc</code>中的命令。  </p>
<p>(2) 对别名进行转义<br>若希望忽略当前定义的别名，可以对使用的命令进行转义，例如<code>\cp</code>。在不可信环境下执行特权命令，通过在命令前加上\来忽略可能存在的别名设置总是一个不错的安全实践。</p>
<h4 id="14-转换、获取和设置日期"><a href="#14-转换、获取和设置日期" class="headerlink" title="14. 转换、获取和设置日期"></a>14. 转换、获取和设置日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">将日期转换成Unix纪元时（以秒为单位）：</span><br><span class="line">date --date &quot;Thu Nov 18 08:00:00 IST 2010&quot; +%s</span><br><span class="line"></span><br><span class="line">根据日期获知星期几:</span><br><span class="line">date --date &quot;Jan 20 2001&quot; +%A</span><br><span class="line"></span><br><span class="line">设置时间:</span><br><span class="line">date -s &quot;21 June 2009 11:01:22&quot;</span><br><span class="line"></span><br><span class="line">打印纪元时(调用两次可用于计算命令执行的花费时间)：</span><br><span class="line">date +%s</span><br><span class="line"></span><br><span class="line">打印对应格式的时间:</span><br><span class="line">date &quot;+%d %B %Y&quot;</span><br><span class="line">20 May 2010</span><br></pre></td></tr></table></figure>

<h4 id="15-调试脚本"><a href="#15-调试脚本" class="headerlink" title="15. 调试脚本"></a>15. 调试脚本</h4><p>(1) 部分调试<br>set -x：在执行时显示参数和命令<br>set +x：禁止调试<br>set -v：当命令进行读取时显示输入<br>set +v：禁止打印输入 </p>
<p>(2) 启用调试  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">sh -x script.sh  </span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">#!/bin/bash -xv</span><br><span class="line">$ ./script.sh</span><br></pre></td></tr></table></figure>

<h4 id="16-函数和参数"><a href="#16-函数和参数" class="headerlink" title="16. 函数和参数"></a>16. 函数和参数</h4><p>(1) 定义函数   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 执行函数<br>只需要使用函数名就可以调用某个函数，并可在函数名后传递参数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fname arg1 arg2;</span><br></pre></td></tr></table></figure>

<p>(3) 访问函数相关参数<br>$0：执行的脚本名<br>$n：传递给脚本的第n个参数(n&gt;0)<br>$#：传递给脚本的参数个数<br>$@：以列表形式打印所有参数<br>$*：类似于$@，但是参数被作为单个实体<br>$?：上一个命令的返回值  </p>
<h4 id="17-Fork炸弹"><a href="#17-Fork炸弹" class="headerlink" title="17. Fork炸弹"></a>17. Fork炸弹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:()&#123; :|:&amp; &#125;;:</span><br></pre></td></tr></table></figure>

<dl><dt>:() # 定义函数,函数名为”:”，即每当输入”:”时就会自动调用{}内代码<br>{ # “:”函数开始标识<br>: # 用递归方式调用”:”函数本身<br>| # 并用管道(pipe)将其输出引至…<br>: # 另一次递归调用的”:”函数<br># 综上，”:|:”表示的即是每次调用函数”:”的时候就会生成两份拷贝<br>&amp; # 调用间脱钩，以使最初的”:”函数被杀死后为其所调用的两个”:”函数还能继续执行<br>} # “:”函数结束标识<br>; # “:”函数定义结束后将要进行的操作…</dt><dd># 调用”:”函数，”引爆”fork炸弹  </dd></dl><h4 id="18-读取字符"><a href="#18-读取字符" class="headerlink" title="18. 读取字符"></a>18. 读取字符</h4><p>(1) 选项-n：读取2个字符并存入变量var  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ read -n 2 var</span><br></pre></td></tr></table></figure>

<p>(2) 选项-s：用无回显的方式读取密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ read -s var</span><br></pre></td></tr></table></figure>

<p>(3) 选项-p：显示提示信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ read -p &quot;Enter input: &quot; var</span><br></pre></td></tr></table></figure>

<p>(4) 选项-t：在特定时限内读取输入(单位：秒)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ read -t 2 var</span><br></pre></td></tr></table></figure>

<p>(5) 选项-d：用特定的定界符作为输入行的结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ read -d &quot;:&quot; var</span><br></pre></td></tr></table></figure>

<h4 id="19-字段分隔符和迭代器"><a href="#19-字段分隔符和迭代器" class="headerlink" title="19. 字段分隔符和迭代器"></a>19. 字段分隔符和迭代器</h4><p>IFS：内部字段分隔符，IFS的默认值为空白字符（换行符、制表符或空格）。<br>CSV：逗号分隔型数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">data=&quot;name,sex,rollno,location&quot;</span><br><span class="line"></span><br><span class="line">oldIFS=$IFS</span><br><span class="line">IFS=,</span><br><span class="line">for item in $data</span><br><span class="line">do</span><br><span class="line">    echo Item: $item</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">IFS=$oldIFS</span><br></pre></td></tr></table></figure>

<h4 id="20-for循环的格式"><a href="#20-for循环的格式" class="headerlink" title="20. for循环的格式"></a>20. for循环的格式</h4><p>(1) shell命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for var in list</span><br><span class="line">do</span><br><span class="line">    commands;</span><br><span class="line">done</span><br><span class="line">注意：list既可以是字符串，也可以是序列！</span><br></pre></td></tr></table></figure>

<p>(2) C语言格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((i=0;i&lt;10;i++))</span><br><span class="line">&#123;</span><br><span class="line">    commands;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-序列的生成"><a href="#21-序列的生成" class="headerlink" title="21. 序列的生成"></a>21. 序列的生成</h4><p>生成一个从1~50的数字列表：echo {1..50}<br>生成字母列表：echo {a..z} 或 {A..Z} 或 {a..h}</p>
<h4 id="22-条件表达式代替if条件判断"><a href="#22-条件表达式代替if条件判断" class="headerlink" title="22. 条件表达式代替if条件判断"></a>22. 条件表达式代替if条件判断</h4><p>(1) 代替if语句  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action;  # 如果condition为真，则执行action；  </span><br><span class="line">[ condition ] || action;  # 如果condition为假，则执行action。</span><br></pre></td></tr></table></figure>

<p>(2) 代替if..else语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action1 || action2;  # 如果condition为真，执行action1，否则执行action2</span><br></pre></td></tr></table></figure>

<h4 id="23-、-、-amp-amp-、-、-a、-o"><a href="#23-、-、-amp-amp-、-、-a、-o" class="headerlink" title="23. []、[[]]、&amp;&amp;、||、-a、-o"></a>23. []、[[]]、&amp;&amp;、||、-a、-o</h4><p>(1) “[[“是关键字，许多shell(如ash bsh)并不支持这种方式。”[“是一条命令， 与test等价，大多数shell都支持。<br>(2) [ … ]为shell命令，在其中的表达式是它的命令行参数，所以串比较操作符”&gt;” 与”&lt;”必须转义，否则就变成IO改向操作符了。而在[[ … ]]中”&lt;”与”&gt;”不需转义。<br>(3) [[ … ]]支持算术扩展，而[ … ]不支持。<br>(4) [[ … ]]支持正则，而[ … ]不支持。  </p>
<p>(5) 在使用”[[ … ]]”时，不能使用”-a”或”-o”对多个条件进行连接，只能使用”&amp;&amp;”或”||”。<br>(6) 在使用”[ … ]”时，如果使用”-a”或”-o”对多个条件进行连接，-a”或”-o”必须被包含在”[ ]”之内。<br>(7) 在使用”[ … ]”时，如果使用”&amp;&amp;”或”||”对多个条件进行连接，”&amp;&amp;”或”||”必须在”[ ]”之外。  </p>
<p>(8) [[ … &amp;&amp; … ]] 和 [ … -a … ] 不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路。  </p>
<p><strong>注意：</strong><br>(1) 使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误！<br>(2) 使用字符串比较时，在=前后各有一个空格，如果遗漏，则变成了赋值语句。  </p>
<h4 id="24-cat命令"><a href="#24-cat命令" class="headerlink" title="24. cat命令"></a>24. cat命令</h4><p>选项-s：摆脱多余的（连续若干行）空白行<br>选项-n：显示行号  </p>
<h4 id="25-文件查找与文件列表–find命令"><a href="#25-文件查找与文件列表–find命令" class="headerlink" title="25. 文件查找与文件列表–find命令"></a>25. 文件查找与文件列表–find命令</h4><p>find命令的选项分为两部分：  1. 查询条件； 2. 针对查询结果的操作选项。<br>(1) 查询条件的选项：</p>
<ul>
<li>根据文件名或正则表达式进行搜索（-name | -iname）<br>iname表示指定文件名并忽略字母大小写  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/admin -name &quot;*.txt&quot; -print</span><br><span class="line">$ find . -iname &quot;example*&quot; -print</span><br><span class="line">$ find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \) -print</span><br><span class="line">注意：</span><br><span class="line">1. -o表示采用OR条件操作</span><br><span class="line">2. \( ... \)用于将-name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;视为一个整体</span><br></pre></td></tr></table></figure>

<ul>
<li>将文件路径作为一个整体进行匹配（-path）   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/users -path &quot;*/cxf/*&quot; -print</span><br><span class="line">匹配以下路径：</span><br><span class="line">/home/users/list/cxf/test.log</span><br><span class="line">/home/users/cxf/eg.css</span><br></pre></td></tr></table></figure>

<ul>
<li>根据正则表达式匹配（-regex | -iregex）<br>iregex表示指定忽略大小写的正则表达式  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面的命令匹配.py或.sh文件：</span><br><span class="line">$ find . regex &quot;.*\(\.py\|\.sh\)$&quot;</span><br><span class="line">$ find . iregex &quot;.*\(\.py\|\.sh\)$&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>否定参数（!）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . ! -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<ul>
<li>基于目录深度的搜索  </li>
<li>maxdepth: 查找的最大深度  </li>
<li>mindepth: 查找的最小深度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find . -maxdepth 1 -name &quot;f*&quot; -print</span><br><span class="line">./fdisk</span><br><span class="line"></span><br><span class="line">$ find . -mindepth 2 -name &quot;f*&quot; -print</span><br><span class="line">./dir1/dir2/file1</span><br><span class="line">./dir3/dir4/f2</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 当前目录的深度为1。</span><br><span class="line">2. -maxdepth和-mindepth应该作为find的第一个查询参数出现，提升咨询效率，不然shell可能会出现警告！</span><br></pre></td></tr></table></figure>

<ul>
<li><p>根据文件类型进行搜索（-type）<br>f: 普通文件<br>l: 符号链接<br>d: 目录<br>c: 字符设备<br>b: 块设备<br>s: 套接字<br>p: FIFO  </p>
</li>
<li><p>根据文件时间进行搜索（+表示大于，-表示小于）  </p>
</li>
<li><p>atime: 访问时间  </p>
</li>
<li><p>mtime: 修改时间</p>
</li>
<li><p>ctime: 变化时间</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">打印最近7天内被访问的所有文件：</span><br><span class="line">$ find . -type f -atime -7 -print</span><br><span class="line"></span><br><span class="line">打印恰好在7天前被访问的所有文件：</span><br><span class="line">$ find . -type f -atime 7 -print</span><br><span class="line"></span><br><span class="line">打印访问时间超过7天的所有文件：</span><br><span class="line">$ find . -type f -atime +7 -print</span><br><span class="line"></span><br><span class="line">打印比参考文件更新的（更近的修改时间）所有文件：</span><br><span class="line">$ find . -type f -newer filename -print</span><br></pre></td></tr></table></figure>

<ul>
<li>基于文件大小的搜索（-size）<br>b——块（512字节）<br>c——字节<br>w——字（2字节）<br>k——1024字节<br>M——1024K字节<br>G——1024M字节  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查找大于2KB的文件：</span><br><span class="line">$ find . -type f -size +2k</span><br><span class="line"></span><br><span class="line">查找小于2KB的文件：</span><br><span class="line">$ find . -type f -size -2k</span><br><span class="line"></span><br><span class="line">查找大小等于2KB的文件：</span><br><span class="line">$ find . -type f -size 2k</span><br></pre></td></tr></table></figure>

<ul>
<li>基于文件权限的搜索（-perm）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -perm 640 -print</span><br></pre></td></tr></table></figure>

<ul>
<li>基于文件属主的搜索（-user）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -user root -print</span><br></pre></td></tr></table></figure>

<p>(2) 针对查询结果的操作选项：  </p>
<ul>
<li>打印：-print | -print0</li>
<li>删除：-delete</li>
<li>执行：-exec</li>
<li>跳过：-prune</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name &quot;*.php&quot; ! -perm 644 -print</span><br><span class="line">$ find . -type f -name &quot;*.swp&quot; -delete</span><br><span class="line">$ find . -type f -user root -exec chown cxf &#123;&#125; \;</span><br><span class="line">$ find / \( -name &quot;.git&quot; -prune \) -o \( -type f -print \)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在上面的命令中，{}是一个与-exec选项搭配使用的特殊字符串，对于每一个匹配的文件，{}会被替换成相应的文件名。但需要注意的是，-exec选项只接受单个命令，不能直接使用多个命令，若希望执行多个命令，可将多命令写入脚本文件，-exec则调用这个脚本。</p>
<h4 id="26-xargs命令"><a href="#26-xargs命令" class="headerlink" title="26. xargs命令"></a>26. xargs命令</h4><p>xargs命令应该紧跟在<strong>管道操作之后</strong>，以<strong>标准输入</strong>作为主要的源数据流。xargs命令把从stdin接收到的数据重新格式化（将分隔符移除，用空格进行代替），再将其作为参数提供给其他命令。</p>
<ul>
<li>选项-d：为输入指定一个定制的定界符  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;splitXsplitXsplitXsplit&quot; | xargs -d X</span><br><span class="line">split split split split</span><br></pre></td></tr></table></figure>

<ul>
<li><p>选项-n：指定每次执行包含的参数个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;splitXsplitXsplitXsplit&quot; | xargs -d X -n 2</span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项-I：指定替换字符串，对于每一个命令参数，该字符串都会被从stdin读取到的参数替换掉。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt | xargs -I &#123;&#125; ./test.sh -p &#123;&#125; -l</span><br><span class="line">-p arg1 -l #</span><br><span class="line">-p arg2 -l #</span><br><span class="line">-p arg3 -l #</span><br></pre></td></tr></table></figure>

<ul>
<li>结合find使用xargs  </li>
</ul>
<p><strong>注意</strong>：因为find命令的输出结果的定界符是无法预测的，所以一旦把find的输出作为xargs的输入，就必须将-print0与find结合使用，以字符null(‘\0’)来分隔输出，再用xargs -0将’\0’作为输入定界符。很多文件名都可能包含空格符，xargs很可能误以为空格是定界符（例如，hello text.txt会被xargs误解为hello和text.txt两个文件）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用find匹配并列出所有的.txt文件，然后用xargs将这些文件删除：</span><br><span class="line">$ find . -type f -name &quot;*.txt&quot; -print0 | xargs -0 rm -f</span><br><span class="line">或</span><br><span class="line">$ find . -type f -name &quot;*.txt&quot; -print | xargs -I &#123;&#125; rm -f &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-tr命令"><a href="#27-tr命令" class="headerlink" title="27. tr命令"></a>27. tr命令</h4><p>(1) 字符替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [option] set1 set2</span><br></pre></td></tr></table></figure>

<p>将来自stdin的输入字符从set1映射到set2，然后将输出写入stdout(标准输出)。set1和set2是字符类和字符集。</p>
<ul>
<li>如果set1的长度大于set2，那么set2会不断重复其最后一个字符，直至长度会set1相同。</li>
<li>如果set1的长度小于set2，那么set2中超出set1长度的部分则全部被忽略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROT13加密算法（对加密后的密文再次使用ROT13函数加密，可得原文）：</span><br><span class="line">$ echo &quot;tr came, tr saw, tr conquered.&quot; | tr &apos;a-zA-Z&apos; &apos;n-za-mN-ZA-M&apos;</span><br><span class="line"></span><br><span class="line">用tr将数字序列进行相加：</span><br><span class="line">$ seq 10 | echo $[ $(tr &apos;\n&apos; &apos;+&apos; ) 0 ]</span><br></pre></td></tr></table></figure>

<p>(2) 字符删除<br>选项-d：删除指定的字符集合<br>选项-c：获取set1的补集，最典型的用法是从输入文本中将不在补集中的所有字符全部删除  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | tr -d &apos;[set1]&apos;</span><br><span class="line"></span><br><span class="line">$ echo &quot;Hello 123 world 456&quot; | tr -d &apos;0-9&apos;</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">$ echo &quot;hello 1 char 2 next 4&quot; | tr -d -c &apos;0-9 \n&apos;</span><br><span class="line">1  2  4</span><br></pre></td></tr></table></figure>

<p>(3) 重复字符压缩（压缩输入中连续重复的字符）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tr -s &apos;[set]&apos;</span><br><span class="line"></span><br><span class="line">echo &quot;Hellloooo&quot; | tr -s &apos;lo&apos;</span><br><span class="line">Helo</span><br></pre></td></tr></table></figure>

<h4 id="28-根据扩展名切分文件名"><a href="#28-根据扩展名切分文件名" class="headerlink" title="28. 根据扩展名切分文件名"></a>28. 根据扩展名切分文件名</h4><p>%：非贪婪<br>%%：贪婪<br>.*：从右到左（删除匹配项）    </p>
<p>#：非贪婪   </p>
<p>##：贪婪<br>*.：从左到右（删除匹配项）    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;hello.world.text.log&quot;</span><br><span class="line"></span><br><span class="line">echo $&#123;filename%.*&#125;  # hello.world.text</span><br><span class="line">echo $&#123;filename%%.*&#125;  # hello</span><br><span class="line">echo $&#123;filename#*.&#125;  # world.text.log</span><br><span class="line">echo $&#123;filename##*.&#125;  # log</span><br></pre></td></tr></table></figure>

<h4 id="29-文件权限"><a href="#29-文件权限" class="headerlink" title="29. 文件权限"></a>29. 文件权限</h4><p>(1) 目录的权限说明  </p>
<ul>
<li>目录的读权限(r)允许<strong>读取</strong>目录中文件和子目录的列表；  </li>
<li>目录的写权限(w)允许在目录中<strong>创建或删除</strong>文件或目录；  </li>
<li>目录的执行权限(x)指明是否可以<strong>访问</strong>目录中的文件和子目录。  </li>
</ul>
<p>(2) 文件的特殊权限</p>
<ul>
<li>setuid(S)权限：允许用户以其拥有者的权限来执行可执行文件，即使这个可执行文件是由其他用户运行的。<br>具有setuid权限的文件的权限序列如下：-rwS——。(如果用户的执行位已存在x，则序列为-rws——)。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s file</span><br><span class="line">或</span><br><span class="line">chmod 4xxx file</span><br></pre></td></tr></table></figure>

<ul>
<li>setgid(S)权限：允许以同该目录拥有者所在组相同的有效组权限来允许可执行文件，但这个组和实际发起命令的用户组未必相同。<br>具有setgid权限的文件的权限序列如下：—-rwS—。(如果用户组的执行位已存在x，则序列为—-rws—)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod g+s file</span><br><span class="line">或</span><br><span class="line">chmod 2xxx file</span><br></pre></td></tr></table></figure>

<ul>
<li>粘滞位：是一种应用于目录的权限类型，如果目录设置了粘滞位，则只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，也无能为力。<br>具有粘滞位权限的目录的权限序列如下：——-rwT。(如果其他用户的执行位已存在x，则序列为d——rwt)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +t file</span><br><span class="line">或</span><br><span class="line">chmod 1xxx file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>若希望同时设置上述三个权限，可以执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 7xxx file</span><br></pre></td></tr></table></figure>

<p>(3) 文件权限的设置    </p>
<ul>
<li><p>指定各组和各位的权限（u—文件所有者，g—文件所有者的组，o—其他用户，a—所有用户）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=rx file</span><br></pre></td></tr></table></figure>
</li>
<li><p>为各组增删权限  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w,g=rx,o-rx file</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定各组权限的八进制数值  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(4) 更改文件的属主   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown user filename</span><br><span class="line">或</span><br><span class="line">chown user:group filename</span><br></pre></td></tr></table></figure>

<p>(5) 以递归方式修改文件权限和属主  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 dirname</span><br><span class="line">chown -R user:group dirname</span><br></pre></td></tr></table></figure>

<p>(6) 设置文件为不可修改  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chattr +i file   # 将文件设置为不可修改</span><br><span class="line">chattr -i file   # 移除不可修改属性，使文件恢复可写状态</span><br></pre></td></tr></table></figure>

<h4 id="30-批量生成空白文件"><a href="#30-批量生成空白文件" class="headerlink" title="30. 批量生成空白文件"></a>30. 批量生成空白文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for name in &#123;1..100&#125;.txt  # 注意序列的拼接！</span><br><span class="line">do</span><br><span class="line">    touch $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果文件已经存在，那么touch命令会将与该文件相关的所有时间戳都更改为当前时间。也可通过指定选项，只更改某些时间戳。</p>
<ul>
<li>touch -a ：只更改文件访问时间</li>
<li>touch -m : 只更改文件内容修改时间</li>
</ul>
<h4 id="31-head与tail命令"><a href="#31-head与tail命令" class="headerlink" title="31. head与tail命令"></a>31. head与tail命令</h4><ul>
<li><p>选项-n：指定打印的行数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">打印前10行：（默认）</span><br><span class="line">$ head file</span><br><span class="line"></span><br><span class="line">指定打印前几行：</span><br><span class="line">$ head -n 5 file</span><br><span class="line"></span><br><span class="line">打印除了最后M行之外的所有行</span><br><span class="line">$ head -n -M file</span><br><span class="line"></span><br><span class="line">打印后10行：（默认）</span><br><span class="line">$ tail file</span><br><span class="line"></span><br><span class="line">打印最后5行：</span><br><span class="line">$ tail -n 5 file</span><br><span class="line"></span><br><span class="line">打印除了前M行之外的所有行：</span><br><span class="line">$ tail -n +(M+1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项-f：动态更新输出文件中的新增内容   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -f filename</span><br><span class="line">等价于</span><br><span class="line">tailf filename</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="32-只列出当前路径下目录的各种方法"><a href="#32-只列出当前路径下目录的各种方法" class="headerlink" title="32. 只列出当前路径下目录的各种方法"></a>32. 只列出当前路径下目录的各种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) $ ls -d */</span><br><span class="line">(2) $ ls -F | grep &quot;/$&quot;  # -F选项的输出项会添加一个代表文件类型的字符，文件对应&quot;*&quot;，目录对应&quot;/&quot;</span><br><span class="line">(3) $ ls -l | grep &quot;^d&quot;</span><br><span class="line">(4) $ find . -type d -maxdepth 1 -print</span><br></pre></td></tr></table></figure>

<h4 id="33-统计文件的行数、单词数和字符数"><a href="#33-统计文件的行数、单词数和字符数" class="headerlink" title="33. 统计文件的行数、单词数和字符数"></a>33. 统计文件的行数、单词数和字符数</h4><p>(1) 统计行数（选项-l）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l file</span><br></pre></td></tr></table></figure>

<p>(2) 统计单词数（选项-w）    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc -w file</span><br></pre></td></tr></table></figure>

<p>(3) 统计字符数（选项-c）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc -c file</span><br></pre></td></tr></table></figure>

<p>(4) 统计行数、单词数和字符数（不使用任何选项）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc file</span><br></pre></td></tr></table></figure>

<p>(5) 打印出文件中最长一行的<strong>长度</strong>（选项-L）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc -L file</span><br></pre></td></tr></table></figure>

<h4 id="34-正则表达式"><a href="#34-正则表达式" class="headerlink" title="34. 正则表达式"></a>34. 正则表达式</h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行起始标记</td>
<td>^tux匹配以tux起始地行</td>
</tr>
<tr>
<td>$</td>
<td>行尾标记</td>
<td>tux$匹配tux结尾的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意<strong>一个</strong>字符（只能匹配单个字符）</td>
<td>Hack.匹配Hackl和Hacki</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配包含在[ ]之中的任意<strong>一个</strong>字符</td>
<td>coo[kl]匹配cook或cool</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除[^字符]之外的任意<strong>一个</strong>字符</td>
<td>9[^01]匹配92、93，但不匹配90、91</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配[ ]中指定范围内的任意<strong>一个</strong>字符</td>
<td>[1-5]匹配从1~5的任意一个数字</td>
</tr>
<tr>
<td>?</td>
<td>匹配之前的项<strong>0次或1次</strong></td>
<td>colou?r匹配color或colour，但是不匹配colouur</td>
</tr>
<tr>
<td>+</td>
<td>匹配之前的项<strong>1次或多次</strong></td>
<td>Rollno-9+匹配Rollno-9、Rollno-99，但是不匹配Rollno-</td>
</tr>
<tr>
<td>*</td>
<td>匹配之前的项<strong>0次或多次</strong></td>
<td>co*l匹配cl、col、coool等</td>
</tr>
<tr>
<td>()</td>
<td>创建一个用于匹配的子串</td>
<td>ma(tri)?x匹配max或matrix，不匹配matx</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配之前的项n次</td>
<td>[0-9]{3}匹配任意一个三位数，[0-9]{3}可以扩展为[0-9][0-9][0-9]</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配之前的项<strong>至少</strong>需要匹配n次</td>
<td>[0-9]{2,}匹配任意一个两位或者更多位的数字</td>
</tr>
<tr>
<td>{n,m}</td>
<td>指定之前的项所必需匹配的最小次数和最大次数</td>
<td>[0-9]{2,5}匹配从两位数到五位数之间的任意一个数字</td>
</tr>
<tr>
<td>|</td>
<td>交替——匹配|两边的任意一项</td>
<td>Oct (1st | 2nd)匹配Oct 1st或Oct 2nd</td>
</tr>
<tr>
<td>\</td>
<td>转义符可以将上面介绍的特殊字符进行转义</td>
<td>a\.b匹配a.b，但不能匹配ajb。通过在.之前加\，忽略.的特殊意义</td>
</tr>
</tbody></table>
<h4 id="35-用grep在文件中搜索文本"><a href="#35-用grep在文件中搜索文本" class="headerlink" title="35. 用grep在文件中搜索文本"></a>35. 用grep在文件中搜索文本</h4><p>(1) 搜索包含特定模式的文本行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;match_text&quot; filename</span><br><span class="line">$ grep &quot;match_text&quot; file1 file2 file3 ...</span><br><span class="line">$ echo -e &quot;this is a world\nnex line&quot; | grep word</span><br></pre></td></tr></table></figure>

<p>(2) 使用正则表达式搜索文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -E &quot;[a-z]+&quot; filename  # -E选项意味着扩展(extended)正则表达式</span><br><span class="line">或者</span><br><span class="line">$ egrep &quot;[a-z]+&quot; filename  # egrep是默认允许正则表达式的grep命令</span><br></pre></td></tr></table></figure>

<p>(3) 只输出文件中匹配到的文本部分，而不输出整行（选项-o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo this is a line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure>

<p>(4) 打印除包含match_pattern行之外的所有行（选项-v，将匹配结果反转）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -v match_pattern file</span><br></pre></td></tr></table></figure>

<p>(5) 统计文件或文本中包含匹配字符串的行数（选项-c）（注意：是匹配的行数，而不是匹配次数！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -c &quot;text&quot; filename</span><br><span class="line">$ echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -c &quot;[0-9]&quot;</span><br><span class="line">2  # 输出2表示匹配两行，尽管有6个匹配项，单行出现的多次匹配只被统计一次</span><br></pre></td></tr></table></figure>

<p>(6) 统计文件中匹配项的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p>(7) 打印包含匹配字符串的行号（选项-n）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep linux -n sample1.txt</span><br><span class="line">2:linux is fun</span><br><span class="line"></span><br><span class="line">$ grep linux -n sample1.txt sample2.txt</span><br><span class="line">sample1.txt:2:linux is fun</span><br><span class="line">sample2.txt:2:planetlinux</span><br></pre></td></tr></table></figure>

<p>(8) 打印模式匹配所位于的字符或字节偏移（选项-b、-o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo gnu is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">7:not</span><br></pre></td></tr></table></figure>

<p>(9) 搜索多个文件并找出匹配文本位于哪个文件（选项-l/-L）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line">和-l相反的选项是-L，它会返回一个不匹配的文件列表</span><br></pre></td></tr></table></figure>

<p>(10) 递归搜索文件（选项-R/-r）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;text&quot; . -r -n</span><br></pre></td></tr></table></figure>

<p>(11) 忽略样式中的大小写（选项-i）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello world&quot; | grep -i &quot;HELLO&quot;</span><br></pre></td></tr></table></figure>

<p>(12) 用grep匹配多个样式（选项-e）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;pattern1&quot; -e &quot;pattern2&quot;</span><br><span class="line">$ echo &quot;this is a line of text&quot; | grep -e &quot;this&quot; -e &quot;line&quot; -o</span><br><span class="line">this</span><br><span class="line">line</span><br></pre></td></tr></table></figure>

<p>(13) 在grep搜索中指定或排除文件（选项–include/–exclude）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;main()&quot; . -r --include *.&#123;c,cpp&#125;</span><br><span class="line">$ grep &quot;mian()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line">$ grep &quot;mian()&quot; . -r --exclude-dir dirname</span><br><span class="line">$ grep &quot;mian()&quot; . -r --exclude-from FILE</span><br></pre></td></tr></table></figure>

<p>(14) grep的静默输出（选项-q）<br>在grep的静默模式中，grep命令不会输出任何内容。如果命令运行成功会返回0，如果失败则返回非0值。</p>
<p>(15) 打印匹配文本之前或之后的行（选项-A、-B、-C）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">打印匹配某个结果之后的3行（总共返回1+3行），使用-A选项（After）</span><br><span class="line">$ seq 10 | grep 5 -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">打印匹配某个结果之前的3行（总共返回1+3行），使用-B选项（Before）</span><br><span class="line">$ seq 10 | grep 5 -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">打印匹配某个结果之前以及之后的3行（总共返回1+3+3行），使用-C选项</span><br><span class="line">$ seq 10 | grep 5 -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h4 id="36-用cut按列切分文本"><a href="#36-用cut按列切分文本" class="headerlink" title="36. 用cut按列切分文本"></a>36. 用cut按列切分文本</h4><p>(1) 提取特定的列（选项-f）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f FIELD_LIST filename</span><br><span class="line">$ cut -f1 filename  # 显示第一列</span><br><span class="line">$ cut -f 2,3 filename  # 显示第2列和第3列</span><br></pre></td></tr></table></figure>

<p>(2) 提取特定列的补集（选项–complement）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f3 --complement data.txt  # 打印除了第3列之外的所有列</span><br></pre></td></tr></table></figure>

<p>(3) 指定字段的定界符（选项-d）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f2 -d&quot;;&quot; data.txt</span><br></pre></td></tr></table></figure>

<p>(4) 指定字段的字符或字节范围</p>
<ul>
<li>-b：表示字节</li>
<li>-c：表示字符</li>
<li>-f：用于定义字段</li>
<li>–output-delimiter：自定义定界符，分割提取的多个字段</li>
</ul>
<table>
<thead>
<tr>
<th>记法</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>N-</td>
<td>从第N个字节，字符或字段到行尾</td>
</tr>
<tr>
<td>N-M</td>
<td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
<tr>
<td>-M</td>
<td>从第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat range_fields.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line"></span><br><span class="line">打印第1个到第5个字符：</span><br><span class="line">$ cut -c1-5 range_fields.txt</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"></span><br><span class="line">打印前2个字符：</span><br><span class="line">$ cut range_fields.txt -c -2</span><br><span class="line"></span><br><span class="line">打印多个字段，并自定义定界符：</span><br><span class="line">$ cut range_fields.txt -c 1-3,6-9 --output-delimiter &quot;,&quot;</span><br><span class="line">abc,fghi</span><br><span class="line">abc,fghi</span><br><span class="line">abc,fghi</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
<h4 id="37-使用sed进行文本替换"><a href="#37-使用sed进行文本替换" class="headerlink" title="37. 使用sed进行文本替换"></a>37. 使用sed进行文本替换</h4><p>(1) 替换给定文本中的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">只替换每一行中第一处符合模式的内容：</span><br><span class="line">$ sed &apos;s/pattern/replace_string/&apos; file</span><br><span class="line">或者</span><br><span class="line">$ cat file | sed &apos;s/pattern/replace_string/&apos;</span><br><span class="line"></span><br><span class="line">替换所有符合模式的内容（命令尾部加上参数g）：</span><br><span class="line">$ sed &apos;s/pattern/replace_string/g&apos; file</span><br><span class="line"></span><br><span class="line">从第N处匹配开始替换内容，使用/Ng选项：</span><br><span class="line">$ echo thisthisthisthis | sed &apos;s/this/THIS/3g&apos;</span><br><span class="line">thisTHISTHISTHIS</span><br></pre></td></tr></table></figure>

<p>(2) 替换字符串的同时保存更改，将替换结果应用于原文件（选项-i）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i &apos;s/text/replace/g&apos; file</span><br></pre></td></tr></table></figure>

<p>注意：字符/在sed中被作为定界符，也可以使用任意字符作为定界符。但是当定界符出现在样式内部时，必须用前缀\对它进行转义！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s:text:replace:g&apos;</span><br><span class="line">sed &apos;s|text|replace|g&apos;</span><br><span class="line">sed &apos;s|te\|xt|replace|g&apos;</span><br><span class="line"></span><br><span class="line">$ echo thisthisthisthis | sed &apos;sTthisT\THIST3g&apos;</span><br><span class="line">thisthisTHISTHIS</span><br></pre></td></tr></table></figure>

<p>(3) 移除空白行（==/pattern/d==会移除匹配样式的行，空白行可以用正则表达式 ==^$== 匹配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed &apos;/^$/d&apos; file</span><br></pre></td></tr></table></figure>

<p>(4) 已匹配字符串标记（&amp;）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo this is an example | sed &apos;s/\w\+/[&amp;]/g&apos;</span><br><span class="line">[this] [is] [an] [example]</span><br></pre></td></tr></table></figure>

<p>正则表达式\w\+匹配每一个单词，然后用[&amp;]替换它。</p>
<p>(5) 子串匹配标记（\1、\2，向后引用）<br>\(pattern\)用于匹配子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ echo this is digit 7 in a number | sed &apos;s/digit \([0-9]\)/\1/&apos;</span><br><span class="line">this is 7 in a number</span><br><span class="line"></span><br><span class="line">$ echo seven EIGHT | sed &apos;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&apos;</span><br><span class="line">EIGHT seven</span><br><span class="line"></span><br><span class="line">$ echo seven EIGHT nine TEN | sed &apos;s/\([a-z]\+\) \([A-Z]\+\)/[&amp;]:\2 \1;/g&apos;</span><br><span class="line">[seven EIGHT]:EIGHT seven; [nine TEN]:TEN nine;</span><br></pre></td></tr></table></figure>

<p>(6) 组合多个表达式  </p>
<ul>
<li>sed ‘expression’ | sed ‘expression’</li>
<li>sed ‘expression; expression’</li>
<li>sed -e ‘expression’ -e ‘expression’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo abc | sed &apos;s/a/A/&apos; | sed &apos;s/c/C/&apos;</span><br><span class="line">$ echo abc | sed &apos;s/a/A/;s/c/C/&apos;</span><br><span class="line">$ echo abc | sed -e &apos;s/a/A/&apos; -e &apos;s/c/C/&apos;</span><br><span class="line">AbC</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(7) 引用<br>sed表达式通常用单引号来引用，不过也可以用双引号，双引号会通过对表达式求值来对其进行扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ text=hello</span><br><span class="line">$ echo hello world | sed &quot;s/$text/HELLO/&quot;</span><br><span class="line">$ echo hello world | sed &apos;s/&apos;$text&apos;/HELLO/&apos;</span><br><span class="line">HELLO world</span><br></pre></td></tr></table></figure>

<h4 id="38-使用awk进行高级文本处理"><a href="#38-使用awk进行高级文本处理" class="headerlink" title="38. 使用awk进行高级文本处理"></a>38. 使用awk进行高级文本处理</h4><p>(1) 脚本结构（awk脚本被包含在单引号或双引号之间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123; statements &#125; pattern &#123; statements &#125; END &#123; end statements &#125;&apos;</span><br><span class="line">或者</span><br><span class="line">awk &quot;BEGIN &#123; statements &#125; pattern &#123; statements &#125; END &#123; end statements &#125;&quot;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">$ awk &apos;BEGIN &#123; i=0 &#125; &#123; i++ &#125; END &#123; print i &#125;&apos; filename</span><br></pre></td></tr></table></figure>

<p>(2) 工作原理<br>Step1: 执行BEGIN { commands }语句块中的语句；<br>Step2: 从文件或stdin中读取一行，然后执行pattern { commands }。重复这个过程，直到文件全部被读取完毕；<br>Step3: 当读至输入流末尾时，执行END { commands }语句块。<br><strong>注意：</strong>  </p>
<ul>
<li>BEGIN语句块在awk开始从输入流中<strong>读取行之前</strong>被执行，END语句块在awk从输入流中<strong>读取完所有的行之后</strong>被执行。BEGIN和END都是可选语句块。</li>
<li>pattern样式是可选的，如果没有提供样式，那么awk会认为所有的行都是匹配的，并执行pattern语句块。重要的是，pattern语句块同样是可选的，只是如果不提供该语句块，则默认执行{ print }，即打印所读取到的每一行。但是，在BEGIN和END语句块均未提供的情况下，pattern样式和语句块至少需要存在其一。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;line1\nline2&quot; | awk &apos;BEGIN &#123; print &quot;Start&quot; &#125; &#123; print &#125; END &#123; print &quot;End&quot; &#125;&apos;</span><br><span class="line">Start</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意，关于print，需要记住两件重要的事情：</p>
<ul>
<li><p>当print的参数是以逗号进行分隔时，参数打印时则以空格作为定界符；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo | awk &apos;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; &#125;&apos;</span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在awk的print语句中，双引号内的字符是被当作拼接操作符使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo | awk &apos;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1 &quot;-&quot; var2 &quot;+&quot; var3; &#125;&apos;</span><br><span class="line">v1-v2+v3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意：上述示例中，echo命令向标准输出写入一行，因此awk的{}语句块只被执行一次。如果awk的标准输入包含多行，那么{}语句块会被执行多次。</p>
<p>(3) 特殊变量  </p>
<ul>
<li>NR：表示记录数量，在执行过程中对应于<strong>当前行号</strong>。</li>
<li>NF：表示字段数量，在执行过程中对应于<strong>当前行的字段数</strong>。</li>
<li>$0：该变量包含执行过程中<strong>当前行</strong>的文本内容。</li>
<li>$1：该变量包含<strong>第一个字段</strong>的文本内容。</li>
<li>$2：该变量包含<strong>第二个字段</strong>的文本内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;line1 f2 f3\nline2 f4 f5\nline3 f6 f7&quot; | \</span><br><span class="line">  awk &apos;&#123; print &quot;Line no:&quot;NR, &quot;No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3 &#125;&apos;</span><br><span class="line">Line no:1 No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3</span><br><span class="line">Line no:2 No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5</span><br><span class="line">Line no:3 No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7</span><br><span class="line"></span><br><span class="line">统计文件中的行数：</span><br><span class="line">$ awk &apos;END &#123; print NR &#125;&apos; file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意:  </p>
<ul>
<li>每读入一行，awk会将NR更新为对应的行号。当到达最后一行时，NR的值就是最后一行的行号。</li>
<li>awk的printf()函数语法和C语言中的同名函数一样。</li>
<li>$NF表示最后一个字段，则$(NF-1)可以表示倒数第二个字段。</li>
</ul>
<p>(4) 将外部变量值传递给awk（选项-v）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">$ VAR=100</span><br><span class="line">$ echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos;</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">$ var1=&quot;VARIABLE1&quot;; var2=&quot;VARIABLE2&quot;</span><br><span class="line">$ echo | awk &apos;&#123; print v1,v2 &#125;&apos; v1=$var1 v2=$var2</span><br><span class="line">或</span><br><span class="line">$ awk &apos;&#123; print v1,v2 &#125;&apos; v1=$var1 v2=$var2 filename</span><br><span class="line">VARIABLE1 VARIABLE2</span><br><span class="line">如上所示，变量之间用空格分隔，以键-值对形式作为awk的命令行参数紧跟在BEGIN、&#123;&#125;和END语句块之后。</span><br></pre></td></tr></table></figure>

<p>(5) 使用过滤模式对awk处理的行进行过滤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;NR &lt; 5&apos;  # 行号小于5的行</span><br><span class="line">$ awk &apos;NR==1,NR==4&apos;  # 行号在1到4之间的行</span><br><span class="line">$ awk &apos;/linux/&apos;  # 包含模式linux的行（可以用正则表达式来指定模式）</span><br><span class="line">$ awk &apos;!/linux/&apos;  # 不包含模式为linux的行</span><br><span class="line">$ awk &apos;/start_pattern/,/end_pattern/&apos; filename  # 打印处于start_pattern与end_pattern之间的文本</span><br></pre></td></tr></table></figure>

<p>(6) 设置字段的定界符<br>默认的字段定界符是空格。可以用-F “delimiter”明确指定一个定界符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&quot;:&quot; &apos;&#123; PRINT $NF &#125;&apos; /etc/passwd</span><br><span class="line">或者</span><br><span class="line">$ awk &apos;BEGIN &#123; IFS=&quot;:&quot; &#125; &#123; PRINT $NF &#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure>

<p>(7) 在awk中使用循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;10;i++) &#123; print $i; &#125;</span><br><span class="line">或者</span><br><span class="line">for(i in array) &#123; print array[i]; &#125;</span><br></pre></td></tr></table></figure>

<p>(8) awk内建的字符串控制函数<br>略。</p>
<h4 id="39-文本切片及参数操作"><a href="#39-文本切片及参数操作" class="headerlink" title="39. 文本切片及参数操作"></a>39. 文本切片及参数操作</h4><ul>
<li><p>文本替换：${var/target/replaced}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var=&quot;This is a line of text&quot;</span><br><span class="line">$ echo $&#123;var/line/REPLACED&#125;</span><br><span class="line">This is a REPLACED of text</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符子串：${var:start_position:length}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ string=abcdefghijklmnopqrstuvwxyz</span><br><span class="line">$ echo $&#123;string:4:8&#125;</span><br><span class="line">efghijkl</span><br><span class="line"></span><br><span class="line">$ echo $&#123;string:(-2):2&#125;  # position为负数表示从后向前计数</span><br><span class="line">yz</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="40-用tar归档"><a href="#40-用tar归档" class="headerlink" title="40. 用tar归档"></a>40. 用tar归档</h4><p>tar支持的参数包括：<br>c: create，创建<br>x: exact，提取<br>v: verbose，详细细节<br>f: filename，指定文件名<br>r: 追加<br>t: 列出归档文件名<br>C: 指定提取目录<br>A: tar包合并   </p>
<p>(1) 用tar对文件进行归档（选项-c）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf output.tar [SOURCE]</span><br><span class="line">$ tar -cf output.tar file1 file2 folder1 ..</span><br></pre></td></tr></table></figure>

<p>(2) 列出归档文件中所包含的文件（选项-t）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$tar -tf archive.tar</span><br><span class="line">file1</span><br><span class="line">file2</span><br></pre></td></tr></table></figure>

<p>(3) 归档或列出归档文件列表时获知更多细节信息（选项-v或-vv）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tvf archive.tar</span><br><span class="line">-rw-rw-r-- admin/ops 0 2013-05-06 21:00 file1</span><br></pre></td></tr></table></figure>

<p>注意：文件名必须紧跟在-f之后，而且-f应该时选项众的最后一个。  </p>
<p>(4) 向归档文件中添加文件（选项-r）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -rvf original.tar new_file</span><br></pre></td></tr></table></figure>

<p>(5) 从归档文件中提取文件或文件夹（选项-x），可以制定提取到哪个目录（选项-C）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf archive.tar</span><br><span class="line">$ tar -xf archive.tar -C /path/to/extraction_directory  # 提取归档文件的全部内容</span><br><span class="line">$ tar -xvf archive.tar file1 file3  # 将文件名指定为命令行参数，提取特定的文件</span><br></pre></td></tr></table></figure>

<p>(6) 拼接两个归档文件（选项-A）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -Af file1.tar file2.tar  # 将file2.tar的内容合并到file1.tar中</span><br></pre></td></tr></table></figure>

<p>(7) 通过检查时间戳来更新归档文件中的内容（选项-u，只有比归档文件中的同名文件更新时才会被添加）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -uf archive.tar filea  # 仅当filea自上次被加入archive.tar后出现了变动才对其进行添加</span><br></pre></td></tr></table></figure>

<p>(8) 从归档文件中删除文件（选项–delete）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -f archive.tar --delete file1 file2 ..</span><br><span class="line">或者</span><br><span class="line">$ tar --delete --file archive.tar [FILE LIST]</span><br></pre></td></tr></table></figure>

<p>(9) 从归档中排除部分文件（选项–exclude／-X）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf archive.tar * --exclude &quot;*.txt&quot;  # 排除所有txt文件</span><br><span class="line">或者</span><br><span class="line">$ tar -cf archive.tar * -X file_contained_list</span><br></pre></td></tr></table></figure>

<p>(10) 打印总字节数（选项–totals）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf archive.tar --exclude &quot;*.txt&quot; --totals</span><br></pre></td></tr></table></figure>

<h4 id="41-用zip归档和压缩"><a href="#41-用zip归档和压缩" class="headerlink" title="41. 用zip归档和压缩"></a>41. 用zip归档和压缩</h4><p>(1) 对件采用ZIP格式进行压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip archive.zip [SOURCE FILES/DIRS]</span><br></pre></td></tr></table></figure>

<p>(2) 对目录和文件进行递归操作（选项-r）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r archive.zip folder1 folder2</span><br></pre></td></tr></table></figure>

<p>(3) 从ZIP文件中提取内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip archive.zip</span><br></pre></td></tr></table></figure>

<p>(4) 更新压缩文件中的内容（选项-u）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip archive.zip -u newfile</span><br></pre></td></tr></table></figure>

<p>(5) 从压缩文件中删除内容（选项-d）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -d archive.zip file.txt</span><br></pre></td></tr></table></figure>

<p>(6) 列出压缩文件中的内容（选项-l）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -l archive.zip</span><br></pre></td></tr></table></figure>

<h4 id="42-用rsync备份系统快照"><a href="#42-用rsync备份系统快照" class="headerlink" title="42. 用rsync备份系统快照"></a>42. 用rsync备份系统快照</h4><ul>
<li>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。</li>
<li>相对于cp命令，rsync的优势在于使用了高效的差异算法。</li>
<li>另外，它还支持网络数据传输。</li>
<li>在进行复制的同时，rsync会比较源端和目的端的文件，只有当文件有更新时才进行复制。</li>
<li>rsync所使用的源路径和目的路径既可以是本地路径，也可以是远程路径。</li>
<li>rsync与scp的定位不同：scp(security cp)侧重于安全、加密地进行主机间的数据拷贝；而rsync侧重于利用差异计算及压缩技术最小化数据传输。</li>
<li>rsync用SSH连接远程主机，因此必须使用username@host:PATH这种形式设定远程主机的地址和备份目录。</li>
</ul>
<p>(1) 将源目录复制到目的端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -av source_path destination_path</span><br><span class="line">例如：</span><br><span class="line">$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span><br></pre></td></tr></table></figure>

<p>注意：选项-a表示进行归档；选项-v表示在stdout上打印出细节信息或进度。  </p>
<p>(2) 将数据备份到远程服务器或主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -av source_dir username@host:PATH</span><br></pre></td></tr></table></figure>

<p>(3) 将远程主机上的数据恢复到本地主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz username@host:PATH destination</span><br></pre></td></tr></table></figure>

<p>(4) 指定在网络传输时压缩数据（选项-z）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -av source destination</span><br></pre></td></tr></table></figure>

<p>(5) 将一个目录中的内容同步到另一个目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -av /home/test/ /home/backups   # 不包括目录本身</span><br><span class="line">$ rsync -av /home/test  /home/backups   # 包括目录本身</span><br><span class="line">注意：区别在于源路径的格式，末尾是否使用&quot;/&quot;</span><br><span class="line"></span><br><span class="line">$ rsync -av /home/test /home/backups/  # 将来自源端的内容复制到目的端目录</span><br><span class="line">$ rsync -av /home/test /home/backups   # 在目的端路径尾部创建同名目录，将来自源端的内容复制到该目录</span><br><span class="line">注意：区别在于目的端路径的格式，末尾是否使用&quot;/&quot;</span><br></pre></td></tr></table></figure>

<p>(6) 归档过程中排除部分文件（选项–exclude PATTERN/–exclude-from FILE）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz SOURCE DESTINATION --exclude &quot;*.txt&quot;  # 不对txt文件进行备份</span><br></pre></td></tr></table></figure>

<p>(7) 更新rsync备份时，删除不存在的文件（选项–delete）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync -avz SOURCE DESTINATION --delete</span><br></pre></td></tr></table></figure>

<h4 id="43-监视磁盘使用情况"><a href="#43-监视磁盘使用情况" class="headerlink" title="43. 监视磁盘使用情况"></a>43. 监视磁盘使用情况</h4><ul>
<li>df (disk free): 磁盘可用情况</li>
<li>du (disk usage): 磁盘使用情况</li>
</ul>
<p>(1) 查询某个文件（或多个文件）占用的磁盘空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du file1 file2 ..</span><br></pre></td></tr></table></figure>

<p>(2) 查询某个目录目录中所有文件的磁盘使用情况（选项-a）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -a DIRECTORY</span><br></pre></td></tr></table></figure>

<p>(3) 以KB、MB等友好的格式显示磁盘使用情况（选项-h）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du - h FILENAME</span><br></pre></td></tr></table></figure>

<p>(4) 显示磁盘使用总计（选项-c/选项-s(summarize)）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ du -c FILENAME1 FILENAME2 ..</span><br><span class="line">$ du -c DIRECTORY</span><br><span class="line"></span><br><span class="line">$ du -sh FILES</span><br><span class="line">$ du -sh DIRECTORY  # 配合-h打印出人们易读的格式</span><br></pre></td></tr></table></figure>

<p>(5) 用特定的单位打印文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ du -b FILE(S)  # 字节（默认输出）</span><br><span class="line">$ du -k FILE(S)  # KB</span><br><span class="line">$ du -m FILE(S)  # MB</span><br><span class="line">$ du -B BLOCK_SIZE FILE(S)  # 块，其中BLOCK_SIZE以字节为单位</span><br></pre></td></tr></table></figure>

<p>(6) 从磁盘使用统计中排除部分文件（选项–exclude/–exclude-from）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ du --exclude &quot;*.txt&quot; FILES  # 通配符</span><br><span class="line">$ du --exclude-from EXCLUDE.txt DIRECTORY  # EXCLUDE.txt包含了需要排除的文件列表</span><br><span class="line">$ du --max-depth 2 DIRECTORY  # 指定du应该遍历的目录层次的最大深度</span><br><span class="line">$ du -x DIRECTORY  # 只对单个文件系统进行遍历，将子目录包含的其他挂载点排除在外</span><br></pre></td></tr></table></figure>

<p>(7) 查找指定目录中最大的n个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -ak SOURCE_DIR | sort -nrk 1 | head -n NUM</span><br></pre></td></tr></table></figure>

<p>(8) <strong>磁盘可用空间信息</strong>(*****)<br>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。df的-h选项会以易读的格式打印磁盘空间信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure>

<h4 id="44-收集进程信息"><a href="#44-收集进程信息" class="headerlink" title="44. 收集进程信息"></a>44. 收集进程信息</h4><ul>
<li><p>ps命令<br>(1) -f(full)：显示多列<br>(2) -e(every)/-ax(all)：显示系统中的每个进程<br>(3) -o：指定想要显示的列<br>常用的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e 或 $ ps -ax</span><br><span class="line">$ ps -ef 或 $ ps -axf</span><br></pre></td></tr></table></figure>
</li>
<li><p>pgrep命令（获得特定命令的进程ID列表）<br>pgrep只需要参数的一部分作为输入参数来提取Bash命令，注入pgrep ash或者pgrep bas都能够奏效，但是ps -C需要输入命令的准确全名。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pgrep -u root,slynux COMMAND   # 指定进程的用户（拥有者）列表</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="45-杀死进程"><a href="#45-杀死进程" class="headerlink" title="45. 杀死进程"></a>45. 杀死进程</h4><ul>
<li>信号列表（信号名称 + 信号编号）<br>SIGHUP 1——对控制进程或终端的终结进行挂起检测<br>SIGINT 2——当按下Ctrl+C时发送该信号<br>SIGKILL 9——用于强行杀死进程<br>SIGTERM 15——默认用于终止进程<br>SIGTSTP 20——当按下Ctrl+Z时发送该信号  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill -s SIGNAL PID  # 参数SIGNAL要么是信号名称，要么是信号编号。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(1) kill命令（以进程ID作为参数）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kill -s SIGKILL PID  # 强行杀死进程：(-s + 信号名称)</span><br><span class="line">$ kill -9 PID   # 强行杀死进程：(-信号编号)</span><br></pre></td></tr></table></figure>

<p>(2) killall命令（以进程名作为参数） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ killall -s SIGNAL PROCESS_NAME</span><br><span class="line">$ killall -9 PROCESS_NAME</span><br><span class="line">$ killall -u USERNAME PROCESS_NAME  # 通过名称以及所属用户名指定进程</span><br></pre></td></tr></table></figure>

<p>(3) pkill命令（以进程名作为参数） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pkill -s SIGNAL PROCESS_NAME</span><br><span class="line">$ pkill -9 PROCESS_NAME</span><br></pre></td></tr></table></figure>

<h4 id="46-用cron进行调度"><a href="#46-用cron进行调度" class="headerlink" title="46. 用cron进行调度"></a>46. 用cron进行调度</h4><p>(1) cron表的格式<br><strong>分钟 小时 天 月份 星期几 命令</strong>  </p>
<ul>
<li>星号（*）指定命令应该在每个时间段执行</li>
<li>在分钟字段使用*/5，表示每5分钟运行一次命令</li>
<li>如果希望在某个特定的时刻执行命令，那么就在对应的时间字段指定时刻（多个时刻用逗号分割）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">每天每小时的第2分钟执行脚本test.sh</span><br><span class="line">02 * * * * sh /home/slynux/test.sh</span><br><span class="line"></span><br><span class="line">每天的第5、6、7小时执行脚本</span><br><span class="line">00 5,6,7 * * sh /home/slynux/test.sh</span><br><span class="line"></span><br><span class="line">周日的每12小时执行脚本</span><br><span class="line">00 */12 * * 0 /home/slynux/test.sh</span><br><span class="line"></span><br><span class="line">每天凌晨2点关闭计算机</span><br><span class="line">00 02 * * * /sbin/shutdown -h</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(2) 查看cron表（选项-l）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line">$ crontab -l -u slynux</span><br></pre></td></tr></table></figure>

<p>(3) 删除cron表（选项-r）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -r</span><br><span class="line">$ crontab -u slynux -r</span><br></pre></td></tr></table></figure>

<h4 id="47-查找命令的位置"><a href="#47-查找命令的位置" class="headerlink" title="47. 查找命令的位置"></a>47. 查找命令的位置</h4><p>(1) which命令用来查找某个命令的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>

<p>(2) whereis命令与which命令类似，但不仅返回命令的路径，还会打印出其对应的命令手的位置以及命令源代码的路径（如果有的话）。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.<span class="number">1</span>.gz</span><br></pre></td></tr></table></figure>

<!-- separator -->
<h3 id="二-Shell经典样例"><a href="#二-Shell经典样例" class="headerlink" title="二. Shell经典样例"></a>二. Shell经典样例</h3><h4 id="1-生成延时"><a href="#1-生成延时" class="headerlink" title="1.生成延时"></a>1.生成延时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo -n Count:</span><br><span class="line">tput sc  # 存储光标位置</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    if [ $count -lt 30 ]; then</span><br><span class="line">        let count++</span><br><span class="line">        sleep 1</span><br><span class="line">        tput rc  # 恢复光标位置</span><br><span class="line">        tput ed  # 清除从当前光标位置到行尾之间的内容</span><br><span class="line">        echo -n $count</span><br><span class="line">    else</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="2-条件判断与-、-、-amp-amp-、-、-a、-o"><a href="#2-条件判断与-、-、-amp-amp-、-、-a、-o" class="headerlink" title="2. 条件判断与[[]]、[]、&amp;&amp;、||、-a、-o"></a>2. 条件判断与[[]]、[]、&amp;&amp;、||、-a、-o</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># -a只能用于[]内的条件连接，不能用于[[]]内，也不能用于括号（[]和[[]]）之间的条件连接</span><br><span class="line">if [ 2 -ge 1 -a 2 -lt 3 ]; then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># &amp;&amp;可以用于[[]]内或[[]]之间，也可以用于[]之间，但是不能用于[]内</span><br><span class="line">if [[ 2 -ge 1 &amp;&amp; 2 -lt 3 ]]; then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 必须将[]内的&quot;&gt;&quot;和&quot;&lt;&quot;进行转义才能正确使用，否则判断结果是错误的，尽管脚本不会报错</span><br><span class="line">if [ &quot;str1&quot; \&gt; &quot;str0&quot; ] &amp;&amp; [ &quot;str1&quot; \&lt; &quot;str2&quot; ]; then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># [[]]内的&quot;&gt;&quot;和&quot;&lt;&quot;不需要转义</span><br><span class="line">if [[ &quot;str1&quot; &gt; &quot;str0&quot; ]] &amp;&amp; [[ &quot;str1&quot; &lt; &quot;str2&quot; ]]; then</span><br><span class="line">   echo true</span><br><span class="line">else</span><br><span class="line">   echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># [[]]内支持算术运算，[]内不支持。注意：运算符&quot;+&quot;两边不能留空格！</span><br><span class="line">if [[ 99+1 -eq 100 ]]; then</span><br><span class="line">    echo true</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># [[]]内支持正则，[]内不支持</span><br><span class="line">regex=&apos;.*\.sh$&apos;</span><br><span class="line">if [[ &quot;$0&quot; =~ $regex ]]; then</span><br><span class="line">    echo match</span><br><span class="line">else</span><br><span class="line">    echo dismatch</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>(1) [ … ]为shell命令，在其中的表达式是它的命令行参数，所以串比较操作符”&gt;” 与”&lt;”必须转义，否则就变成IO改向操作符了。而在[[ … ]]中”&lt;”与”&gt;”不需要转义。<br>(2) [[ … ]]支持算术扩展，而[ … ]不支持。<br>(3) [[ … ]]支持正则，而[ … ]不支持。<br>(4) 在使用”[[ … ]]”时，不能使用”-a”或”-o”对多个条件进行连接，只能使用”&amp;&amp;”或”||”。<br>(5) 在使用”[ … ]”时，如果使用”-a”或”-o”对多个条件进行连接，-a”或”-o”必须被包含在”[ ]”之内。<br>(6) 在使用”[ … ]”时，如果使用”&amp;&amp;”或”||”对多个条件进行连接，”&amp;&amp;”或”||”必须在”[ ]”之外。  </p>
<h4 id="3-交互输入自动化"><a href="#3-交互输入自动化" class="headerlink" title="3. 交互输入自动化"></a>3. 交互输入自动化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">spawn ./interactive.sh</span><br><span class="line">expect &quot;Enter number:&quot;</span><br><span class="line">send &quot;1\n&quot;</span><br><span class="line">expect &quot;Enter name:&quot;</span><br><span class="line">send &quot;hello\n&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>spawn参数指定需要自动化的命令；<br>expect参数提供需要等待的消息；<br>send是要发送的消息；<br>expect eof指明命令交互结束。  </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/Shell/" rel="tag"># Shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/01/Java类加载详解/" rel="next" title="Java类加载详解">
                <i class="fa fa-chevron-left"></i> Java类加载详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/23/算法与数据结构系列-拓扑排序/" rel="prev" title="算法与数据结构系列-拓扑排序">
                算法与数据结构系列-拓扑排序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://ww3.sinaimg.cn/mw690/eab689f0jw8f12gq1h4q0j20ig0igjsh.jpg" alt="RicheyCheng">
            
              <p class="site-author-name" itemprop="name">RicheyCheng</p>
              <p class="site-description motion-element" itemprop="description">认真生活，快乐工作</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/richeycheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:chengxiaofuzju@gmail.com" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-envelope"></i>Email</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-Linux-shell-脚本攻略"><span class="nav-text">一. Linux shell 脚本攻略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-命令行的起始标志"><span class="nav-text">1. 命令行的起始标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-shebang文本行"><span class="nav-text">2. shebang文本行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Bash分隔符"><span class="nav-text">3. Bash分隔符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-终端打印命令—echo"><span class="nav-text">4. 终端打印命令—echo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-终端打印命令—printf"><span class="nav-text">5. 终端打印命令—printf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-赋值与相等"><span class="nav-text">6. 赋值与相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-export命令"><span class="nav-text">7. export命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-检查用户是否为root"><span class="nav-text">8. 检查用户是否为root</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-反引用与子shell"><span class="nav-text">9. 反引用与子shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-数学运算"><span class="nav-text">10. 数学运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-bc"><span class="nav-text">11. bc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-数组与关联数组"><span class="nav-text">12. 数组与关联数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-别名"><span class="nav-text">13. 别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-转换、获取和设置日期"><span class="nav-text">14. 转换、获取和设置日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-调试脚本"><span class="nav-text">15. 调试脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-函数和参数"><span class="nav-text">16. 函数和参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Fork炸弹"><span class="nav-text">17. Fork炸弹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-读取字符"><span class="nav-text">18. 读取字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-字段分隔符和迭代器"><span class="nav-text">19. 字段分隔符和迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-for循环的格式"><span class="nav-text">20. for循环的格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-序列的生成"><span class="nav-text">21. 序列的生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-条件表达式代替if条件判断"><span class="nav-text">22. 条件表达式代替if条件判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-、-、-amp-amp-、-、-a、-o"><span class="nav-text">23. []、[[]]、&amp;&amp;、||、-a、-o</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-cat命令"><span class="nav-text">24. cat命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-文件查找与文件列表–find命令"><span class="nav-text">25. 文件查找与文件列表–find命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-xargs命令"><span class="nav-text">26. xargs命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-tr命令"><span class="nav-text">27. tr命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-根据扩展名切分文件名"><span class="nav-text">28. 根据扩展名切分文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-文件权限"><span class="nav-text">29. 文件权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-批量生成空白文件"><span class="nav-text">30. 批量生成空白文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-head与tail命令"><span class="nav-text">31. head与tail命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-只列出当前路径下目录的各种方法"><span class="nav-text">32. 只列出当前路径下目录的各种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-统计文件的行数、单词数和字符数"><span class="nav-text">33. 统计文件的行数、单词数和字符数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-正则表达式"><span class="nav-text">34. 正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-用grep在文件中搜索文本"><span class="nav-text">35. 用grep在文件中搜索文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-用cut按列切分文本"><span class="nav-text">36. 用cut按列切分文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-使用sed进行文本替换"><span class="nav-text">37. 使用sed进行文本替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38-使用awk进行高级文本处理"><span class="nav-text">38. 使用awk进行高级文本处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-文本切片及参数操作"><span class="nav-text">39. 文本切片及参数操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-用tar归档"><span class="nav-text">40. 用tar归档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-用zip归档和压缩"><span class="nav-text">41. 用zip归档和压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-用rsync备份系统快照"><span class="nav-text">42. 用rsync备份系统快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-监视磁盘使用情况"><span class="nav-text">43. 监视磁盘使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-收集进程信息"><span class="nav-text">44. 收集进程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-杀死进程"><span class="nav-text">45. 杀死进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-用cron进行调度"><span class="nav-text">46. 用cron进行调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-查找命令的位置"><span class="nav-text">47. 查找命令的位置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-Shell经典样例"><span class="nav-text">二. Shell经典样例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-生成延时"><span class="nav-text">1.生成延时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-条件判断与-、-、-amp-amp-、-、-a、-o"><span class="nav-text">2. 条件判断与[[]]、[]、&amp;&amp;、||、-a、-o</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-交互输入自动化"><span class="nav-text">3. 交互输入自动化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RicheyCheng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
